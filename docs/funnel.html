<!DOCTYPE html>

<html>
<head>
  <title>funnel.litcoffee</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="public/stylesheets/normalize.css" />
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div class="container">
    <div class="page">

      <div class="header">
        
          <h1>funnel.litcoffee</h1>
        

        
      </div>

      
        
        <h2>Funnel.js</h2>

        
      
        
        <p>The goal of Funnel is to provide an elegant way to build large, scalable,
reactive apps without the need for magically scaling databases or super 
ninja skills.</p>
<p>This is an experimental serial implementation of Funnel.js API. Its main
purpose is to iron out a solid Funnel API before a serious implementation
begins.</p>
<h2>The Funnel class</h2>
<p>Our implementation is contained in our <code>Funnel</code> class, for now this is where we
define all functions public and private that are required to make run Funnel&#39;s
event loop according to the spec.</p>

        
          <div class='highlight'><pre><span class="class"><span class="keyword">class</span> <span class="title">Funnel</span></span></pre></div>
        
      
        
        <h3>Public API</h3>
<p>This is the functionality that the user is expected to implement.</p>
<h4>Creating a new Funnel object</h4>
<p>The constructor is passed on object of rules. Rules are simply functions that
get automatically called with the results of other rules when all the
dependancies of the rule have been satisfied.</p>
<p>A rules dependancies are specified by the arguments it takes, you simply use the
name of the rule you depend on as the argument name and <code>Funnel</code> recognizes it
as a dependancy. The dependancies are considered satisfied when all of them have
been executed at least once. </p>
<p>It is important to note that there is work that is done to transform the output
of a rule into the input of another.</p>
<ol>
<li>Rules that were executed more than once in the time it took to satisfy the
dependancies have their results passed through as an array.</li>
<li>Rules with a single dependancy that has returned an array as its result are
called once with each of the items in the array.</li>
</ol>

        
          <div class='highlight'><pre>  constructor: ( <span class="property">@rules</span> ) -&gt;
    <span class="property">@compile</span>()</pre></div>
        
      
        
        <h4>Listening to the results of your funnel</h4>
<p>Listening to your funnel is the same as adding an anonymous rule. The only
difference is that you are guarenteed access to the scope where you defined your
listener function. The reason normal rules don&#39;t come with this guarentee is
that it will be much easier to scale a Funnel if we are only passing around
arguments.</p>

        
          <div class='highlight'><pre>  listen: ( fn ) =&gt;
    key = <span class="string">"_<span class="subst">#{Object.keys(@rules).length}</span>"</span>
    <span class="property">@rules</span>.key = fn
    <span class="property">@compile</span>()</pre></div>
        
      
        
        <h4>Feeding your funnel data</h4>
<p>Expect this to change, but right now the only way to get data into your funnel
is using the reserved input rule that passes through its arguments.</p>

        
          <div class='highlight'><pre>  input: ( args... ) =&gt;
    <span class="keyword">return</span> <span class="property">@map</span>( <span class="string">'input'</span>, args )</pre></div>
        
      
        
        <h3>Private Functionality</h3>
<p>Funnel.js requires some finesse in order to properly implement the API. This is
Code you should not be calling when you use Funnel.</p>
<h4>Compilation</h4>
<p>Funnel has a very quick compilation step that must happen every time you change
the rules. This is because we have to build the dependancy tree, otherwise we
would have to do a lot more work at runtime figuring out when each rule should
be kicked off.</p>

        
          <div class='highlight'><pre>  compile: =&gt;
    <span class="property">@lca_of_rule</span> = {}
    <span class="keyword">for</span> name, fn <span class="keyword">of</span> <span class="property">@rules</span>
      @[name] = ( args... ) =&gt; <span class="property">@run_rule</span>( name, args )
      <span class="property">@lca_of_rule</span>[name] = <span class="property">@lca</span>( <span class="property">@arg_names</span>( fn )... )</pre></div>
        
      
        
        <h4>Argument parsing</h4>
<p>Funnel needs to know what the names of the arguments are, normal software never
needs to do this, but since Funnel is almost a DSL it needs to do crazy stuff.</p>

        
          <div class='highlight'><pre>  arg_names: ( func ) -&gt;
    reg = <span class="regexp">/\(([\s\S]*?)\)/</span>
    params = reg.exec(func)
    <span class="keyword">return</span> params[<span class="number">1</span>].split(<span class="regexp">/\s*,\s*/</span>) <span class="keyword">if</span> params</pre></div>
        
      
        
        <h4>Lowest common ancestor</h4>
<p>This is the most mathematical part of Funnel. It recursively computes which of
its dependancies is lowest in the dependancy tree so we know which rule we come
after. This happens at compile time and can probably be optimized if need be.</p>

        
          <div class='highlight'><pre>  lca: ( rules... ) =&gt;
    <span class="keyword">if</span> rules.length &gt; <span class="number">2</span>
      <span class="keyword">return</span> <span class="property">@lca</span>( <span class="property">@lca</span>(rules[<span class="number">0.</span>.<span class="number">.2</span>]...), <span class="property">@lca</span>(rules[<span class="number">2.</span>.]...) )
    <span class="keyword">else</span> <span class="keyword">if</span> rules.length <span class="keyword">is</span> <span class="number">1</span>
      <span class="keyword">return</span> rules[<span class="number">0</span>]
    <span class="keyword">else</span>
      [ one, two ] = rules
      one_ancestors = [ ]
      two_ancestors = [ ]
      one_tmp = [ one ]
      two_tmp = [ two ]
      <span class="keyword">while</span> <span class="literal">true</span>
        one_ancestors = one_ancestors.concat( one_tmp )
        two_ancestors = two_ancestors.concat( two_tmp )
        <span class="keyword">for</span> o <span class="keyword">in</span> one_ancestors
          <span class="keyword">return</span> o <span class="keyword">if</span> o <span class="keyword">in</span> two_ancestors
        one_tmp =  [].concat( (<span class="property">@arg_names</span>(<span class="property">@rules</span>[i]) <span class="keyword">for</span> i <span class="keyword">in</span> one_tmp)... )
        two_tmp =  [].concat( (<span class="property">@arg_names</span>(<span class="property">@rules</span>[i]) <span class="keyword">for</span> i <span class="keyword">in</span> two_tmp)... )
        <span class="keyword">break</span> <span class="keyword">if</span> <span class="literal">undefined</span> <span class="keyword">in</span> one_tmp <span class="keyword">and</span> <span class="literal">undefined</span> <span class="keyword">in</span> two_tmp</pre></div>
        
      
        
        <h4>Run the rule</h4>
<p>This code runs a rule once its dependancies have been satisfied. It executes the
rule after standardizing the arguments, and it returns the result of calling map
with the rules output.</p>

        
          <div class='highlight'><pre>  run_rule: ( rule, args ) =&gt;
    args = [ args ] <span class="keyword">unless</span> Object::toString.call( args ) <span class="keyword">is</span> <span class="string">'[object Array]'</span>
    result = <span class="property">@rules</span>[ rule ]( args... )
    <span class="keyword">return</span> <span class="property">@map</span>( rule, result )</pre></div>
        
      
        
        <h4>Extend an object, much like _.extend</h4>
<p>This is used for a couple of things, probably another thing that could get
optimized away at some point.</p>

        
          <div class='highlight'><pre>  extend: ( objects... ) -&gt;
    result = {}
    <span class="keyword">for</span> o <span class="keyword">in</span> objects
      <span class="keyword">for</span> k, v <span class="keyword">of</span> o
        result[k] ?= []
        v = [ v ] <span class="keyword">unless</span> Object::toString.call( v ) <span class="keyword">is</span> <span class="string">'[object Array]'</span>
        result[k] = result[k].concat(v...)
    <span class="keyword">return</span> result</pre></div>
        
      
        
        <h4>MAP-REDUCE!!!</h4>
<p>The analogy here is purely self indulgent as I&#39;m fairly certain that Funnel
could no longer be implemented as a map reduce script. However since it was
origionally intended as a framework for mapreduce, and it helps me conceptualize
the complex behavior required to carry through the execution of Funnel with all
the appropriate dependancies, I will leave it as an imperfect analogy.</p>
<p>The <code>reduce</code> function is responsible for handling all of the rules that have
more than one dependancy. The name is such because it turns n inputs into one
output.</p>

        
          <div class='highlight'><pre>  reduce: ( rule, outputs ) =&gt;
    <span class="keyword">for</span> n, fn <span class="keyword">of</span> <span class="property">@rules</span>
      a = <span class="property">@arg_names</span>( fn )
      args = []
      args.push( ( outputs[i] <span class="keyword">for</span> i <span class="keyword">in</span> a )... )
      <span class="keyword">if</span> a.length &gt; <span class="number">1</span> <span class="keyword">and</span> <span class="property">@lca_of_rule</span>[ n ] <span class="keyword">is</span> rule
        o = <span class="property">@run_rule</span>( n, args )
        outputs = <span class="property">@extend</span>( outputs, o )
    <span class="keyword">return</span> outputs</pre></div>
        
      
        
        <p>The <code>map</code> function handles all the rules with only one dependancy, thus it tends
to take a single input and turn it into many outputs. Additionally, if the input
to a rule is in the form of an array, the map function will split the array and
call the rule once with each of its items.</p>

        
          <div class='highlight'><pre>  map: ( rule, result ) =&gt;
    <span class="keyword">if</span> Object::toString.call( result ) <span class="keyword">is</span> <span class="string">'[object Array]'</span>
      <span class="keyword">return</span> <span class="property">@extend</span>( ( <span class="property">@map</span>(rule, r) <span class="keyword">for</span> r <span class="keyword">in</span> result )... )
    <span class="keyword">else</span>
      output = {}
      <span class="keyword">for</span> n, fn <span class="keyword">of</span> <span class="property">@rules</span>
        a = <span class="property">@arg_names</span>( fn )
        <span class="keyword">if</span> a.length <span class="keyword">is</span> <span class="number">1</span> <span class="keyword">and</span> <span class="property">@lca_of_rule</span>[ n ] <span class="keyword">is</span> rule
          o = <span class="property">@run_rule</span>( n, result )
          o[ rule ] = result
          o = <span class="property">@reduce</span>( rule, o )
          output = <span class="property">@extend</span>( output, o )
      output[ rule ] ?= result
      <span class="keyword">return</span> output</pre></div>
        
      
        
        <p>Export Funnel for all to use! It may be worth figuring out how to hide private
functionality.</p>

        
          <div class='highlight'><pre>module.exports = Funnel</pre></div>
        
      
      <div class="fleur">h</div>
    </div>
  </div>
</body>
</html>
